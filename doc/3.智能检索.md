严格按照以下要求实现智能检索功能，以下是功能描述：
1.整个检索功能主要分为三个部分：理解(SearchRouteService.py)、召回(SearchFormatService.py)和融合、上下文拼装与回答生成（SearchAnswerService.py）
2.SearchRoutes.py中实现接口的入参和返参处理，不要处理任何业务内容
3.SearchRouteService.py实现Query 理解与路由
1）分类器（轻量）：判断查询类型（定义/事实/比较/流程/规范/数值/位置/FAQ/表格字段/图像相关）
2）实体识别：在Query中识别可能的“实体/别名/产品型号/批号”等
3）改写与扩展：
生成 BM25 友好的关键字/短语（含同义词、英文别名）
生成 向量检索的语义化query
生成 图谱查询意图（如：询问“X 的组成/适用范围/依赖关系/相互作用”）
4）路由规则：
若包含强结构意图（如“谁隶属于谁”“A的参数范围”）→ 优先图谱
若是规范/术语定义 → BM25 与 Vector 双检索
若问表格字段或数值 → 给 BM25 增加 type:table过滤，并提高表格块权重

4.SearchFormatService.py中实现三路召回、融合与去重、重排（Re-ranking）
1）三路召回
A. 倒排（BM25）
must: 关键短语（phrase query）
should: 同义词扩展词
filter: 权限/时间/文档类型/部门
对标题字段加权（title^3），表格字段加权（table^2），近期文档时间衰减或增益
B. 向量（语义）
以向量化后的 query 向量检索 top K（如 K=50）
融合多通道向量（纯文本向量、标题向量、表格向量），做并集后去重
C. 图谱（结构化）
优先实体锚定：根据 NER+EL 找到实体节点
根据意图模板拼 Cypher：
组成/部件：(a:Product)-[:HAS_PART]->(b:Component)
适用范围：(a:Kit)-[:APPLICABLE_TO]->(b:CellLine)
规范引用：(a)-[:CITED_BY|REFER_TO]->(b:Standard)
将图谱结果回填为证据，并将相关 doc_id/chunk_id 加入候选
2）融合与去重
三路候选合并后，同源 chunk 合并去重（相似度>0.9 视为重复）
分值归一化（min-max 或 z-score）
融合策略：
RRF（Reciprocal Rank Fusion）简单稳健
或线性加权：score = α*bm25 + β*vector + γ*graph_boost
graph_boost：若为图谱精确命中实体/关系，给予常数加分（如 +0.15）
3）重排（Re-ranking）
用 Cross-Encoder（如 bge-reranker-large）对 Top N（如 100→20）逐对打分
去毒与清洗：过滤“格式垃圾块/低信息密度块/表格空白块”
多样性控制（MMR）：防止20条都来自同一文档的连续块

5.SearchAnswerService.py实现上下文拼装与回答生成
1）证据拼装（Context Builder）
同文档相邻块合并（阈值：同页且距离小于X像素；同section_path）
表格强化：对命中的表格，取所在行/列邻域一起提供
图片/图表：附带 caption + OCR 文本 + 页面截图链接
2）保留原格式输出
对 PDF：提供 page_no + bbox，前端用 Canvas 高亮；或生成图片快照URL（对象存储）
对 HTML：保留 DOM 片段 + 样式 class
在最终答案里插入 可点击“查看原文位置” 的锚点链接（doc_id+page_no+bbox）
3）生成答案（可选 LLM）
Prompt 模板包含：
用户问题
精炼后的多证据（带来源编号）
风格要求：先答案结论→再要点→再引用
严格要求“不得编造，若证据不足请明示”
输出结构：
结论/直接答案（如有）
证据要点（条目化，精确字段/数值）
引用（[1] [2]…每条对应 doc_id/chunk/page）
查看原文按钮/链接
6.要求
1）整个过程需要流式响应，在三个环节中都需要流式响应理解过成、召回融合过程、答案生成过程，最终展示一个带有格式的答案


优化流式响应：
1.intelligent_search这个接口产生的答案不要一次性发给前端，而是边生成边往前端推流，后端一边构造答案，一边通过流（SSE 或 WebSocket/WebRTC，取决于 API）把增量片段（delta）发给页面，页面即时渲染。
2.因为完整的答案以文本为主，可能附带图片、表格、图表等多模态内容，所以每出一小段文本，服务端就发送一个stream 事件（增量内容），如果遇到图片、表格、图表等需要流发送“渲染图片/表格/图表”的事件通知，然后等后端渲染好图片/表格/图表等含结构、样式完整内容后再通过流推送给页面，页面即时渲染。
3.图片/表格/图表的详细说明
模型输出的是 Markdown/JSON 等文本，前端在收到完整块时重新渲染：
表格：当 | 行、表头/分隔行凑成可解析结构时，渲染器就能把它画出来；
代码块：当收到完整的 ``` 结束围栏，就高亮渲染；
图片：当流里出现完整的 ![](url) 或内部资源引用时，前端再单独发起图片请求加载，并非“图片数据本身被逐字节流”。
4.深度分析后端这三个环节：理解(SearchRouteService.py)、召回(SearchFormatService.py)和融合、上下文拼装与回答生成（SearchAnswerService.py）如何合理的使用流推送增量信息，让用户有极好的体验


重构检索功能：
1.在线检索总流程
Query → ①规范化 → ②意图判别（标题/碎句）
     → ③候选召回（向量 + BM25）
     → ④按 section 聚合 & 融合
     → ⑤重排（交叉编码器）
     → ⑥选中 Top-1 section_id
     → ⑦扩展（图谱/缓存 → 一家子）
     → ⑧补图表细节（MySQL）
     → ⑨组装/渲染（高亮证据，支持流式输出）
2.详细说明
① 规范化（Query Normalization）
全角/半角、空白与标点标准化；中文英文之间加空格
同义词扩展（HCP↔宿主蛋白；CHO-K1↔CHOK1 等）
移除低信息词（可选）
② 意图判别（标题问法 or 碎句问法）
优先走轻模型/规则而非 LLM：
规则：长度≤8 字、含“简介/说明/是什么/定义/产品说明/概述”等 → 标题问法
向量相似：sim(query_emb, title_only_centroid) ≥ 0.45 → 标题问法
其余 → 碎句问法（正文）
判别不确定（0.40–0.45）时两路并跑，最后由重排决定走向。
③ 候选召回（快而广）
标题问法
向量：titles Top-20
BM25：sections_bm25 Top-20
碎句问法
向量：fragments Top-50
BM25：fragments_bm25 Top-50（collapse by section_id，保 inner_hits 作为证据）
④ 聚合与分数融合（到 section 粒度）
把所有命中按 section_id group；记录该节内证据片段列表（Top-3 elem_id）
分数归一（min-max 或 z-score）后做 RRF 或线性加权融合：
score = 0.5*vec_norm + 0.5*bm25_norm
取 Top-20~50 个 section 作为重排候选
⑤ 重排（把“最相关的一节”放到第一）
模型：bge-reranker-base/large（中文/混合），或 Cohere Rerank
输入对：(query, rerank_text_for_section)
rerank_text_for_section = 标题 + 该节最相关的 2–3 个片段（≤512 tokens）
批量打分，降序排序 → 选 Top-1（或 Top-3） section_id
片段级高亮：对入选节内证据 elem_id 再用重排选 1–3 条作为最终高亮。
⑥ 阈值与多候选兜底
若 Top-1 分数 < τ_low（如 0.25），尝试第二候选；仍低则走降级回答（仅给出最相近节的纯文本并提示“未加载结构化资源”）。
同名标题跨文档：加 doc_id/version 过滤；或 UI 让用户点选。
⑦ 扩展（把“一家子”拉齐）
使用Neo4j
MATCH (s:Section {section_id:$sid})-[r:HAS_CONTENT]->(n)
RETURN s, n, r.order ORDER BY r.order
得到标题 + 段落/要点 + 表格节点 + 图片节点（含 elem_id/page/bbox 与 order）。
⑧ 图表细节（MySQL）
figures WHERE section_id = ? → image_path/caption/bbox_norm
tables WHERE section_id = ? + table_rows WHERE table_elem_id IN (?)
如果图谱里已经带 image_path/table_html，这步可省。
⑨ 组装/渲染（可流式）
按 order 输出：标题 → 段落们 → 表格（HTML/行） → 图片
对重排选出的证据 elem_id 做高亮（用 page/bbox 或在文本中标 <mark>）
可在首屏先发“找到章节：xxx”及前两个段落，随后流式追加表格与图片
总体目标：
检索要做的不是“一次命中整段”，而是“先找对 section_id，再把这一节的‘一家子’（文本+表格+图片）端全”。
用“召回（向量+BM25）→ 融合 → 重排 → 图谱扩展 → MySQL 补细节 → 组装/渲染”的分层流程。
要求：
0.删除SearchAnswerService.py、SearchFormatService.py、SearchOpenSearchService.py、SearchRouteService.py几个文件，重构内容全部在SearchService.py文件中实现
1.在SearchRoutes.py文件中只负责处理入参和返参
2.在SearchService.py文件中实现上述的全部内容
3.优化流式响应：
1）intelligent_search这个接口产生的答案不要一次性发给前端，而是边生成边往前端推流，后端一边构造答案，一边通过流（SSE 或 WebSocket/WebRTC，取决于 API）把增量片段（delta）发给页面，页面即时渲染。
2）因为完整的答案以文本为主，可能附带图片、表格、图表等多模态内容，所以每出一小段文本，服务端就发送一个stream 事件（增量内容），如果遇到图片、表格、图表等需要流发送“渲染图片/表格/图表”的事件通知，然后等后端渲染好图片/表格/图表等含结构、样式完整内容后再通过流推送给页面，页面即时渲染。
3）图片/表格/图表的详细说明
模型输出的是 Markdown/JSON 等文本，前端在收到完整块时重新渲染：
表格：当 | 行、表头/分隔行凑成可解析结构时，渲染器就能把它画出来；
代码块：当收到完整的 ``` 结束围栏，就高亮渲染；
图片：当流里出现完整的 ![](url) 或内部资源引用时，前端再单独发起图片请求加载，并非“图片数据本身被逐字节流”。